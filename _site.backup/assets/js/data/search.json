[
  
  {
    "title": "Welcome to My Portfolio!",
    "url": "/posts/welcome-to-my-portfolio/",
    "categories": "Blog, Welcome",
    "tags": "introduction, portfolio, personal",
    "date": "2024-03-14 22:30:00 -0400",
    





    
    "snippet": "Hello Everyone! üëãWelcome to my digital portfolio! I‚Äôm excited to share my journey as a developer and showcase the projects I‚Äôve been working on.What You‚Äôll Find HereThis portfolio serves as a compr...",
    "content": "Hello Everyone! üëãWelcome to my digital portfolio! I‚Äôm excited to share my journey as a developer and showcase the projects I‚Äôve been working on.What You‚Äôll Find HereThis portfolio serves as a comprehensive showcase of my:  Technical projects with detailed case studies  Learning journey and experiences  Tutorials and insights from real-world development  Professional growth and career milestonesAbout This SiteThis portfolio is built with:  Jekyll - Static site generator  Chirpy Theme - Beautiful, responsive design  GitHub Pages - Free, reliable hosting  Markdown - Easy content creationWhat‚Äôs ComingI‚Äôll be regularly updating this site with:  Project showcases - Deep dives into my development work  Technical tutorials - Sharing knowledge and best practices  Career updates - Professional milestones and opportunities  Learning reflections - Insights from new technologies and frameworksGet in TouchI‚Äôm always interested in connecting with fellow developers, potential collaborators, or anyone interested in technology. Feel free to reach out through:  GitHub: Check out my repositories and contributions  LinkedIn: Let‚Äôs connect professionally  Email: Drop me a line about opportunities or collaborationsThank you for visiting, and I hope you find my content valuable. Stay tuned for more exciting updates!This is just the beginning of my portfolio journey. I‚Äôm looking forward to sharing more projects, insights, and experiences with you."
  },
  
  {
    "title": "Building an E-Commerce Platform with MERN Stack",
    "url": "/posts/building-ecommerce-platform/",
    "categories": "Projects, Web Development",
    "tags": "react, nodejs, mongodb, javascript, mern, ecommerce",
    "date": "2024-03-10 01:20:00 -0500",
    





    
    "snippet": "Building a Full-Stack E-Commerce PlatformIn this post, I‚Äôll walk you through my journey of building a comprehensive e-commerce platform using the MERN stack (MongoDB, Express.js, React.js, Node.js)...",
    "content": "Building a Full-Stack E-Commerce PlatformIn this post, I‚Äôll walk you through my journey of building a comprehensive e-commerce platform using the MERN stack (MongoDB, Express.js, React.js, Node.js).Project OverviewDuration: 3 monthsRole: Full-Stack DeveloperTeam Size: Solo projectKey Features Implemented  ‚úÖ User authentication and authorization  ‚úÖ Product catalog with search and filtering  ‚úÖ Shopping cart functionality  ‚úÖ Secure payment integration  ‚úÖ Order management system  ‚úÖ Admin dashboard  ‚úÖ Responsive design  ‚úÖ Real-time inventory trackingTechnical ArchitectureFrontend (React.js)// Example: Product component with hooksimport React, { useState, useEffect } from 'react';import { useDispatch, useSelector } from 'react-redux';import { fetchProducts, addToCart } from '../redux/actions';const ProductList = () =&gt; {  const [loading, setLoading] = useState(true);  const dispatch = useDispatch();  const products = useSelector(state =&gt; state.products);  useEffect(() =&gt; {    dispatch(fetchProducts())      .then(() =&gt; setLoading(false));  }, [dispatch]);  const handleAddToCart = (product) =&gt; {    dispatch(addToCart(product));  };  if (loading) return &lt;div&gt;Loading products...&lt;/div&gt;;  return (    &lt;div className=\"product-grid\"&gt;      {products.map(product =&gt; (        &lt;ProductCard           key={product._id}           product={product}          onAddToCart={() =&gt; handleAddToCart(product)}        /&gt;      ))}    &lt;/div&gt;  );};Backend (Node.js + Express)// Example: Product routes with middlewareconst express = require('express');const { protect, admin } = require('../middleware/authMiddleware');const Product = require('../models/Product');const router = express.Router();// Get all products with pagination and filteringrouter.get('/', async (req, res) =&gt; {  try {    const page = parseInt(req.query.page) || 1;    const limit = parseInt(req.query.limit) || 10;    const skip = (page - 1) * limit;        const filter = {};    if (req.query.category) filter.category = req.query.category;    if (req.query.search) {      filter.$or = [        { name: { $regex: req.query.search, $options: 'i' } },        { description: { $regex: req.query.search, $options: 'i' } }      ];    }    const products = await Product.find(filter)      .skip(skip)      .limit(limit)      .sort({ createdAt: -1 });    const total = await Product.countDocuments(filter);    res.json({      products,      pagination: {        page,        limit,        total,        pages: Math.ceil(total / limit)      }    });  } catch (error) {    res.status(500).json({ message: error.message });  }});// Create product (Admin only)router.post('/', protect, admin, async (req, res) =&gt; {  try {    const product = new Product({      ...req.body,      createdBy: req.user._id    });        await product.save();    res.status(201).json(product);  } catch (error) {    res.status(400).json({ message: error.message });  }});module.exports = router;Database Design (MongoDB)// Product Schemaconst productSchema = new mongoose.Schema({  name: {    type: String,    required: true,    trim: true  },  description: {    type: String,    required: true  },  price: {    type: Number,    required: true,    min: 0  },  category: {    type: String,    required: true  },  images: [{    url: String,    alt: String  }],  inventory: {    quantity: {      type: Number,      required: true,      min: 0    },    lowStockThreshold: {      type: Number,      default: 10    }  },  ratings: {    average: {      type: Number,      default: 0    },    count: {      type: Number,      default: 0    }  },  isActive: {    type: Boolean,    default: true  }}, {  timestamps: true});Challenges Faced &amp; Solutions1. State Management ComplexityChallenge: Managing complex application state across multiple componentsSolution: Implemented Redux with Redux Toolkit for predictable state management2. Payment SecurityChallenge: Handling sensitive payment information securelySolution: Integrated Stripe API with webhook verification and never storing card details3. Performance OptimizationChallenge: Slow loading times with large product catalogsSolution:  Implemented pagination and lazy loading  Added Redis caching for frequently accessed data  Optimized database queries with proper indexing4. Responsive DesignChallenge: Creating consistent user experience across devicesSolution: Used CSS Grid and Flexbox with mobile-first approachKey LearningsTechnical Skills Developed  Advanced React patterns (Context API, Custom Hooks)  RESTful API design principles  Database optimization techniques  Payment gateway integration  Security best practicesSoft Skills Improved  Project planning and time management  Problem-solving and debugging  Documentation and code organization  User experience considerationPerformance Metrics  Load Time: &lt; 2 seconds for product listing  Database Queries: Optimized to &lt; 100ms average  Mobile Performance: 90+ Lighthouse score  Security: A+ SSL Labs ratingFuture Enhancements  Microservices Architecture: Break down monolith for better scalability  Real-time Features: WebSocket integration for live inventory updates  AI Recommendations: Machine learning for personalized product suggestions  Multi-vendor Support: Platform for multiple sellers  Mobile App: React Native implementationLive Demo &amp; Codeüåê Live Demo: https://ecommerce-demo.example.comüíª GitHub Repository: https://github.com/yourusername/mern-ecommerceScreenshotsAdd screenshots of your application here when availableThis project significantly enhanced my full-stack development skills and gave me hands-on experience with production-level challenges. The combination of modern web technologies and real-world requirements made it an invaluable learning experience.What would you like to know more about? Feel free to reach out with questions about the implementation details or any specific aspect of the project!"
  },
  
  {
    "title": "React Best Practices: Lessons from Building Production Apps",
    "url": "/posts/react-best-practices/",
    "categories": "Tutorials, Frontend",
    "tags": "react, javascript, best-practices, performance, clean-code",
    "date": "2024-03-04 20:15:00 -0500",
    





    
    "snippet": "React Best Practices: Lessons Learned from ProductionAfter building several React applications in production, I‚Äôve learned valuable lessons about writing maintainable, performant, and scalable Reac...",
    "content": "React Best Practices: Lessons Learned from ProductionAfter building several React applications in production, I‚Äôve learned valuable lessons about writing maintainable, performant, and scalable React code. Here are the key best practices I follow.1. Component Structure and OrganizationFile Organizationsrc/‚îú‚îÄ‚îÄ components/‚îÇ   ‚îú‚îÄ‚îÄ common/          # Reusable UI components‚îÇ   ‚îú‚îÄ‚îÄ layout/          # Layout components‚îÇ   ‚îî‚îÄ‚îÄ features/        # Feature-specific components‚îú‚îÄ‚îÄ hooks/               # Custom hooks‚îú‚îÄ‚îÄ utils/               # Helper functions‚îú‚îÄ‚îÄ services/            # API calls‚îî‚îÄ‚îÄ constants/           # Application constantsComponent Naming Convention// ‚úÖ Good: PascalCase for componentsconst UserProfile = () =&gt; {  return &lt;div&gt;User Profile&lt;/div&gt;;};// ‚úÖ Good: Descriptive namesconst ProductSearchForm = () =&gt; {  // Component logic};// ‚ùå Avoid: Generic namesconst Component1 = () =&gt; {  // Component logic};2. State Management Best PracticesUse Local State When Possible// ‚úÖ Good: Local state for component-specific dataconst UserForm = () =&gt; {  const [formData, setFormData] = useState({    name: '',    email: ''  });  const handleSubmit = (e) =&gt; {    e.preventDefault();    // Handle form submission  };  return (    &lt;form onSubmit={handleSubmit}&gt;      {/* Form fields */}    &lt;/form&gt;  );};Lift State Up When Needed// ‚úÖ Good: Shared state at appropriate levelconst ParentComponent = () =&gt; {  const [sharedData, setSharedData] = useState([]);  return (    &lt;div&gt;      &lt;ChildA data={sharedData} onUpdate={setSharedData} /&gt;      &lt;ChildB data={sharedData} /&gt;    &lt;/div&gt;  );};3. Custom Hooks for Reusable LogicAPI Data Fetching Hook// Custom hook for API callsconst useApi = (url) =&gt; {  const [data, setData] = useState(null);  const [loading, setLoading] = useState(true);  const [error, setError] = useState(null);  useEffect(() =&gt; {    const fetchData = async () =&gt; {      try {        setLoading(true);        const response = await fetch(url);        if (!response.ok) throw new Error('API call failed');        const result = await response.json();        setData(result);      } catch (err) {        setError(err.message);      } finally {        setLoading(false);      }    };    fetchData();  }, [url]);  return { data, loading, error };};// Usage in componentconst ProductList = () =&gt; {  const { data: products, loading, error } = useApi('/api/products');  if (loading) return &lt;LoadingSpinner /&gt;;  if (error) return &lt;ErrorMessage error={error} /&gt;;  return (    &lt;div&gt;      {products?.map(product =&gt; (        &lt;ProductCard key={product.id} product={product} /&gt;      ))}    &lt;/div&gt;  );};Local Storage Hookconst useLocalStorage = (key, initialValue) =&gt; {  const [storedValue, setStoredValue] = useState(() =&gt; {    try {      const item = window.localStorage.getItem(key);      return item ? JSON.parse(item) : initialValue;    } catch (error) {      console.error(`Error reading localStorage key \"${key}\":`, error);      return initialValue;    }  });  const setValue = (value) =&gt; {    try {      const valueToStore = value instanceof Function ? value(storedValue) : value;      setStoredValue(valueToStore);      window.localStorage.setItem(key, JSON.stringify(valueToStore));    } catch (error) {      console.error(`Error setting localStorage key \"${key}\":`, error);    }  };  return [storedValue, setValue];};4. Performance OptimizationMemoization with React.memo// ‚úÖ Good: Memoize expensive componentsconst ProductCard = React.memo(({ product, onAddToCart }) =&gt; {  return (    &lt;div className=\"product-card\"&gt;      &lt;h3&gt;{product.name}&lt;/h3&gt;      &lt;p&gt;{product.price}&lt;/p&gt;      &lt;button onClick={() =&gt; onAddToCart(product)}&gt;        Add to Cart      &lt;/button&gt;    &lt;/div&gt;  );}, (prevProps, nextProps) =&gt; {  // Custom comparison function (optional)  return prevProps.product.id === nextProps.product.id &amp;&amp;         prevProps.product.price === nextProps.product.price;});useMemo and useCallbackconst ProductList = ({ products, category, onProductClick }) =&gt; {  // Memoize expensive calculations  const filteredProducts = useMemo(() =&gt; {    return products.filter(product =&gt;       category === 'all' || product.category === category    );  }, [products, category]);  // Memoize callback functions  const handleProductClick = useCallback((product) =&gt; {    onProductClick(product);    // Analytics tracking    analytics.track('product_clicked', { productId: product.id });  }, [onProductClick]);  return (    &lt;div&gt;      {filteredProducts.map(product =&gt; (        &lt;ProductCard           key={product.id}          product={product}          onClick={handleProductClick}        /&gt;      ))}    &lt;/div&gt;  );};Code Splitting with React.lazy// Lazy load components for better performanceconst ProductDetails = React.lazy(() =&gt; import('./ProductDetails'));const UserDashboard = React.lazy(() =&gt; import('./UserDashboard'));const App = () =&gt; {  return (    &lt;Router&gt;      &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;        &lt;Routes&gt;          &lt;Route path=\"/product/:id\" element={&lt;ProductDetails /&gt;} /&gt;          &lt;Route path=\"/dashboard\" element={&lt;UserDashboard /&gt;} /&gt;        &lt;/Routes&gt;      &lt;/Suspense&gt;    &lt;/Router&gt;  );};5. Error Handling and BoundariesError Boundary Componentclass ErrorBoundary extends React.Component {  constructor(props) {    super(props);    this.state = { hasError: false, error: null };  }  static getDerivedStateFromError(error) {    return { hasError: true, error };  }  componentDidCatch(error, errorInfo) {    console.error('Error caught by boundary:', error, errorInfo);    // Log to error reporting service    errorReportingService.log(error, errorInfo);  }  render() {    if (this.state.hasError) {      return (        &lt;div className=\"error-fallback\"&gt;          &lt;h2&gt;Something went wrong&lt;/h2&gt;          &lt;p&gt;We're sorry for the inconvenience. Please try refreshing the page.&lt;/p&gt;          &lt;button onClick={() =&gt; window.location.reload()}&gt;            Refresh Page          &lt;/button&gt;        &lt;/div&gt;      );    }    return this.props.children;  }}// Usageconst App = () =&gt; {  return (    &lt;ErrorBoundary&gt;      &lt;Router&gt;        &lt;Routes&gt;          {/* Your routes */}        &lt;/Routes&gt;      &lt;/Router&gt;    &lt;/ErrorBoundary&gt;  );};6. Testing Best PracticesComponent Testing with React Testing Libraryimport { render, screen, fireEvent, waitFor } from '@testing-library/react';import userEvent from '@testing-library/user-event';import ProductForm from './ProductForm';describe('ProductForm', () =&gt; {  const mockOnSubmit = jest.fn();  beforeEach(() =&gt; {    mockOnSubmit.mockClear();  });  test('renders form fields correctly', () =&gt; {    render(&lt;ProductForm onSubmit={mockOnSubmit} /&gt;);        expect(screen.getByLabelText(/product name/i)).toBeInTheDocument();    expect(screen.getByLabelText(/price/i)).toBeInTheDocument();    expect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();  });  test('submits form with correct data', async () =&gt; {    const user = userEvent.setup();    render(&lt;ProductForm onSubmit={mockOnSubmit} /&gt;);    await user.type(screen.getByLabelText(/product name/i), 'Test Product');    await user.type(screen.getByLabelText(/price/i), '99.99');    await user.click(screen.getByRole('button', { name: /submit/i }));    await waitFor(() =&gt; {      expect(mockOnSubmit).toHaveBeenCalledWith({        name: 'Test Product',        price: '99.99'      });    });  });});7. Accessibility Best PracticesSemantic HTML and ARIAconst Modal = ({ isOpen, onClose, title, children }) =&gt; {  useEffect(() =&gt; {    if (isOpen) {      document.body.style.overflow = 'hidden';      // Focus management      document.getElementById('modal-close-button').focus();    } else {      document.body.style.overflow = 'unset';    }    return () =&gt; {      document.body.style.overflow = 'unset';    };  }, [isOpen]);  if (!isOpen) return null;  return (    &lt;div       className=\"modal-overlay\"       onClick={onClose}      role=\"dialog\"      aria-labelledby=\"modal-title\"      aria-modal=\"true\"    &gt;      &lt;div         className=\"modal-content\"         onClick={e =&gt; e.stopPropagation()}      &gt;        &lt;div className=\"modal-header\"&gt;          &lt;h2 id=\"modal-title\"&gt;{title}&lt;/h2&gt;          &lt;button            id=\"modal-close-button\"            onClick={onClose}            aria-label=\"Close modal\"          &gt;            √ó          &lt;/button&gt;        &lt;/div&gt;        &lt;div className=\"modal-body\"&gt;          {children}        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  );};8. Environment and Build ConfigurationEnvironment Variables// .env.developmentREACT_APP_API_URL=http://localhost:3001/apiREACT_APP_ENVIRONMENT=development// .env.productionREACT_APP_API_URL=https://api.production.comREACT_APP_ENVIRONMENT=production// Using in codeconst API_BASE_URL = process.env.REACT_APP_API_URL;const isDevelopment = process.env.REACT_APP_ENVIRONMENT === 'development';Key Takeaways  Keep components small and focused - Single responsibility principle  Use custom hooks for reusable stateful logic  Optimize performance with memoization and code splitting  Handle errors gracefully with error boundaries  Write tests for critical functionality  Consider accessibility from the beginning  Use TypeScript for better developer experience and fewer bugsCommon Mistakes to Avoid  Using useEffect unnecessarily  Not cleaning up event listeners and subscriptions  Mutating state directly  Over-using global state management  Ignoring console warnings  Not implementing proper error handlingThese practices have significantly improved the quality and maintainability of my React applications. The key is to be consistent and always consider the long-term impact of your architectural decisions.What React best practices have you found most valuable in your projects? I‚Äôd love to hear about your experiences!"
  },
  
  {
    "title": "Building a Production-Ready REST API with Node.js and Express",
    "url": "/posts/nodejs-rest-api-guide/",
    "categories": "Tutorials, Backend",
    "tags": "nodejs, express, api, backend, mongodb, authentication",
    "date": "2024-02-28 03:45:00 -0500",
    





    
    "snippet": "Building a Production-Ready REST API with Node.jsIn this comprehensive tutorial, I‚Äôll guide you through building a robust REST API using Node.js and Express, incorporating best practices I‚Äôve learn...",
    "content": "Building a Production-Ready REST API with Node.jsIn this comprehensive tutorial, I‚Äôll guide you through building a robust REST API using Node.js and Express, incorporating best practices I‚Äôve learned from production deployments.Project Setup and StructureInitial Setupmkdir my-api &amp;&amp; cd my-apinpm init -y# Core dependenciesnpm install express mongoose cors helmet morgan dotenv bcryptjs jsonwebtokennpm install express-rate-limit express-validator# Development dependenciesnpm install -D nodemon jest supertestProject Structuremy-api/‚îú‚îÄ‚îÄ src/‚îÇ   ‚îú‚îÄ‚îÄ controllers/     # Route handlers‚îÇ   ‚îú‚îÄ‚îÄ middleware/      # Custom middleware‚îÇ   ‚îú‚îÄ‚îÄ models/         # Database models‚îÇ   ‚îú‚îÄ‚îÄ routes/         # Route definitions‚îÇ   ‚îú‚îÄ‚îÄ utils/          # Utility functions‚îÇ   ‚îî‚îÄ‚îÄ app.js          # Express app setup‚îú‚îÄ‚îÄ tests/              # Test files‚îú‚îÄ‚îÄ .env                # Environment variables‚îî‚îÄ‚îÄ server.js           # Entry pointCore Application SetupExpress Application (src/app.js)const express = require('express');const mongoose = require('mongoose');const cors = require('cors');const helmet = require('helmet');const morgan = require('morgan');const rateLimit = require('express-rate-limit');const authRoutes = require('./routes/auth');const userRoutes = require('./routes/users');const productRoutes = require('./routes/products');const errorHandler = require('./middleware/errorHandler');const { connectDB } = require('./utils/database');const app = express();// Database connectionconnectDB();// Security middlewareapp.use(helmet());app.use(cors({  origin: process.env.FRONTEND_URL,  credentials: true}));// Rate limitingconst limiter = rateLimit({  windowMs: 15 * 60 * 1000, // 15 minutes  max: 100, // Limit each IP to 100 requests per windowMs  message: 'Too many requests from this IP, please try again later.'});app.use(limiter);// Body parsing middlewareapp.use(express.json({ limit: '10mb' }));app.use(express.urlencoded({ extended: true, limit: '10mb' }));// Loggingapp.use(morgan('combined'));// Routesapp.use('/api/auth', authRoutes);app.use('/api/users', userRoutes);app.use('/api/products', productRoutes);// Health check endpointapp.get('/health', (req, res) =&gt; {  res.status(200).json({    status: 'OK',    timestamp: new Date().toISOString(),    uptime: process.uptime()  });});// Error handlingapp.use(errorHandler);// 404 handlerapp.use('*', (req, res) =&gt; {  res.status(404).json({    success: false,    message: 'Route not found'  });});module.exports = app;Database Models with MongooseUser Model (src/models/User.js)const mongoose = require('mongoose');const bcrypt = require('bcryptjs');const userSchema = new mongoose.Schema({  username: {    type: String,    required: [true, 'Username is required'],    unique: true,    trim: true,    minlength: [3, 'Username must be at least 3 characters'],    maxlength: [20, 'Username cannot exceed 20 characters']  },  email: {    type: String,    required: [true, 'Email is required'],    unique: true,    lowercase: true,    match: [/^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/, 'Please enter a valid email']  },  password: {    type: String,    required: [true, 'Password is required'],    minlength: [6, 'Password must be at least 6 characters'],    select: false // Don't include password in queries by default  },  role: {    type: String,    enum: ['user', 'admin'],    default: 'user'  },  isActive: {    type: Boolean,    default: true  },  lastLogin: Date,  createdAt: {    type: Date,    default: Date.now  }}, {  timestamps: true,  toJSON: { virtuals: true },  toObject: { virtuals: true }});// Index for performanceuserSchema.index({ email: 1 });userSchema.index({ username: 1 });// Virtual for user profile URLuserSchema.virtual('profileUrl').get(function() {  return `/api/users/${this._id}`;});// Hash password before savinguserSchema.pre('save', async function(next) {  if (!this.isModified('password')) return next();    this.password = await bcrypt.hash(this.password, 12);  next();});// Compare password methoduserSchema.methods.comparePassword = async function(candidatePassword) {  return await bcrypt.compare(candidatePassword, this.password);};// Update last loginuserSchema.methods.updateLastLogin = async function() {  this.lastLogin = new Date();  await this.save({ validateBeforeSave: false });};module.exports = mongoose.model('User', userSchema);Product Model (src/models/Product.js)const mongoose = require('mongoose');const productSchema = new mongoose.Schema({  name: {    type: String,    required: [true, 'Product name is required'],    trim: true,    maxlength: [100, 'Product name cannot exceed 100 characters']  },  description: {    type: String,    required: [true, 'Product description is required'],    maxlength: [1000, 'Description cannot exceed 1000 characters']  },  price: {    type: Number,    required: [true, 'Product price is required'],    min: [0, 'Price cannot be negative']  },  category: {    type: String,    required: [true, 'Product category is required'],    enum: ['electronics', 'clothing', 'books', 'home', 'sports']  },  inventory: {    quantity: {      type: Number,      required: true,      min: [0, 'Inventory cannot be negative']    },    lowStockThreshold: {      type: Number,      default: 10    }  },  images: [{    url: String,    alt: String  }],  ratings: {    average: {      type: Number,      default: 0,      min: 0,      max: 5    },    count: {      type: Number,      default: 0    }  },  isActive: {    type: Boolean,    default: true  },  createdBy: {    type: mongoose.Schema.Types.ObjectId,    ref: 'User',    required: true  }}, {  timestamps: true});// Indexes for search and filteringproductSchema.index({ name: 'text', description: 'text' });productSchema.index({ category: 1 });productSchema.index({ price: 1 });productSchema.index({ 'ratings.average': -1 });// Virtual for low stock checkproductSchema.virtual('isLowStock').get(function() {  return this.inventory.quantity &lt;= this.inventory.lowStockThreshold;});module.exports = mongoose.model('Product', productSchema);Authentication &amp; AuthorizationJWT Utilities (src/utils/jwt.js)const jwt = require('jsonwebtoken');const generateToken = (payload) =&gt; {  return jwt.sign(payload, process.env.JWT_SECRET, {    expiresIn: process.env.JWT_EXPIRES_IN || '7d'  });};const verifyToken = (token) =&gt; {  return jwt.verify(token, process.env.JWT_SECRET);};module.exports = {  generateToken,  verifyToken};Auth Middleware (src/middleware/auth.js)const { verifyToken } = require('../utils/jwt');const User = require('../models/User');const protect = async (req, res, next) =&gt; {  try {    let token;    // Check for token in headers    if (req.headers.authorization &amp;&amp; req.headers.authorization.startsWith('Bearer')) {      token = req.headers.authorization.split(' ')[1];    }    if (!token) {      return res.status(401).json({        success: false,        message: 'Access denied. No token provided.'      });    }    // Verify token    const decoded = verifyToken(token);        // Check if user still exists    const user = await User.findById(decoded.id).select('-password');    if (!user || !user.isActive) {      return res.status(401).json({        success: false,        message: 'Token is no longer valid'      });    }    req.user = user;    next();  } catch (error) {    res.status(401).json({      success: false,      message: 'Token is not valid'    });  }};const authorize = (...roles) =&gt; {  return (req, res, next) =&gt; {    if (!roles.includes(req.user.role)) {      return res.status(403).json({        success: false,        message: 'Access denied. Insufficient permissions.'      });    }    next();  };};module.exports = {  protect,  authorize};Controllers and Route HandlersAuth Controller (src/controllers/authController.js)const { validationResult } = require('express-validator');const User = require('../models/User');const { generateToken } = require('../utils/jwt');const register = async (req, res) =&gt; {  try {    // Check for validation errors    const errors = validationResult(req);    if (!errors.isEmpty()) {      return res.status(400).json({        success: false,        message: 'Validation failed',        errors: errors.array()      });    }    const { username, email, password } = req.body;    // Check if user already exists    const existingUser = await User.findOne({      $or: [{ email }, { username }]    });    if (existingUser) {      return res.status(400).json({        success: false,        message: 'User already exists with this email or username'      });    }    // Create user    const user = new User({ username, email, password });    await user.save();    // Generate token    const token = generateToken({ id: user._id, email: user.email });    res.status(201).json({      success: true,      message: 'User registered successfully',      data: {        user: {          id: user._id,          username: user.username,          email: user.email,          role: user.role        },        token      }    });  } catch (error) {    res.status(500).json({      success: false,      message: 'Internal server error',      error: process.env.NODE_ENV === 'development' ? error.message : undefined    });  }};const login = async (req, res) =&gt; {  try {    const errors = validationResult(req);    if (!errors.isEmpty()) {      return res.status(400).json({        success: false,        message: 'Validation failed',        errors: errors.array()      });    }    const { email, password } = req.body;    // Find user and include password for comparison    const user = await User.findOne({ email }).select('+password');        if (!user || !user.isActive) {      return res.status(401).json({        success: false,        message: 'Invalid credentials'      });    }    // Check password    const isPasswordValid = await user.comparePassword(password);    if (!isPasswordValid) {      return res.status(401).json({        success: false,        message: 'Invalid credentials'      });    }    // Update last login    await user.updateLastLogin();    // Generate token    const token = generateToken({ id: user._id, email: user.email });    res.json({      success: true,      message: 'Login successful',      data: {        user: {          id: user._id,          username: user.username,          email: user.email,          role: user.role,          lastLogin: user.lastLogin        },        token      }    });  } catch (error) {    res.status(500).json({      success: false,      message: 'Internal server error',      error: process.env.NODE_ENV === 'development' ? error.message : undefined    });  }};module.exports = {  register,  login};Input ValidationValidation Rules (src/utils/validation.js)const { body, param, query } = require('express-validator');const registerValidation = [  body('username')    .isLength({ min: 3, max: 20 })    .withMessage('Username must be between 3 and 20 characters')    .isAlphanumeric()    .withMessage('Username must contain only letters and numbers'),    body('email')    .isEmail()    .withMessage('Please provide a valid email')    .normalizeEmail(),    body('password')    .isLength({ min: 6 })    .withMessage('Password must be at least 6 characters long')    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/)    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, and one number')];const loginValidation = [  body('email')    .isEmail()    .withMessage('Please provide a valid email')    .normalizeEmail(),    body('password')    .notEmpty()    .withMessage('Password is required')];const productValidation = [  body('name')    .isLength({ min: 1, max: 100 })    .withMessage('Product name is required and must be less than 100 characters')    .trim(),    body('description')    .isLength({ min: 10, max: 1000 })    .withMessage('Description must be between 10 and 1000 characters')    .trim(),    body('price')    .isFloat({ min: 0 })    .withMessage('Price must be a positive number'),    body('category')    .isIn(['electronics', 'clothing', 'books', 'home', 'sports'])    .withMessage('Invalid category')];module.exports = {  registerValidation,  loginValidation,  productValidation};Error HandlingGlobal Error Handler (src/middleware/errorHandler.js)const errorHandler = (err, req, res, next) =&gt; {  let error = { ...err };  error.message = err.message;  console.log(err);  // Mongoose bad ObjectId  if (err.name === 'CastError') {    const message = 'Resource not found';    error = { message, statusCode: 404 };  }  // Mongoose duplicate key  if (err.code === 11000) {    const message = 'Duplicate field value entered';    error = { message, statusCode: 400 };  }  // Mongoose validation error  if (err.name === 'ValidationError') {    const message = Object.values(err.errors).map(val =&gt; val.message).join(', ');    error = { message, statusCode: 400 };  }  res.status(error.statusCode || 500).json({    success: false,    message: error.message || 'Server Error'  });};module.exports = errorHandler;TestingTest Setup (tests/setup.js)const mongoose = require('mongoose');const { MongoMemoryServer } = require('mongodb-memory-server');let mongoServer;beforeAll(async () =&gt; {  mongoServer = await MongoMemoryServer.create();  const mongoUri = mongoServer.getUri();    await mongoose.connect(mongoUri, {    useNewUrlParser: true,    useUnifiedTopology: true  });});afterAll(async () =&gt; {  await mongoose.disconnect();  await mongoServer.stop();});afterEach(async () =&gt; {  const collections = mongoose.connection.collections;  for (const key in collections) {    const collection = collections[key];    await collection.deleteMany({});  }});Example Test (tests/auth.test.js)const request = require('supertest');const app = require('../src/app');describe('Auth Endpoints', () =&gt; {  describe('POST /api/auth/register', () =&gt; {    it('should register a new user', async () =&gt; {      const userData = {        username: 'testuser',        email: 'test@example.com',        password: 'Password123'      };      const response = await request(app)        .post('/api/auth/register')        .send(userData)        .expect(201);      expect(response.body.success).toBe(true);      expect(response.body.data.user.email).toBe(userData.email);      expect(response.body.data.token).toBeDefined();    });    it('should not register user with invalid email', async () =&gt; {      const userData = {        username: 'testuser',        email: 'invalid-email',        password: 'Password123'      };      const response = await request(app)        .post('/api/auth/register')        .send(userData)        .expect(400);      expect(response.body.success).toBe(false);      expect(response.body.errors).toBeDefined();    });  });});Environment ConfigurationEnvironment Variables (.env)NODE_ENV=developmentPORT=3000MONGODB_URI=mongodb://localhost:27017/myapiJWT_SECRET=your_super_secret_jwt_key_hereJWT_EXPIRES_IN=7dFRONTEND_URL=http://localhost:3000# Rate limitingRATE_LIMIT_WINDOW_MS=900000RATE_LIMIT_MAX=100# Email service (if needed)EMAIL_SERVICE=sendgridEMAIL_API_KEY=your_email_api_keyKey Takeaways  Security First: Implement proper authentication, input validation, and rate limiting  Error Handling: Use centralized error handling with meaningful error messages  Database Design: Use proper schemas, indexes, and validation  Testing: Write comprehensive tests for all endpoints  Documentation: Document your API thoroughly  Performance: Implement caching, pagination, and database optimization  Monitoring: Add logging and health check endpointsThis foundation provides a solid starting point for building production-ready APIs. Remember to always consider security, performance, and maintainability in your implementation decisions.Have questions about any part of this implementation? Feel free to reach out!"
  }
  
]

